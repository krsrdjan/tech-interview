# tech-interview
Basic tech interview coding assigments

Here’s an explanation of each problem in the minimal LeetCode-style Java interview prep list, categorized by topic. This will help you understand why each one matters and what concepts it tests.

🔁 1. Arrays & Hashing
- Two Sum (Easy)

Find two numbers in an array that add up to a target.
Why: Tests hash map usage, array traversal, and basic problem-solving.

- Contains Duplicate (Easy)

Check if any element appears more than once.
Why: Covers hash sets and frequency counting.

- Product of Array Except Self (Medium)

Return an array where each element is the product of all others except itself, without using division.
Why: Tests prefix/suffix techniques and constant space logic.

- Top K Frequent Elements (Medium)

Return the K most frequent elements in an array.
Why: Requires understanding of frequency maps, heaps, or bucket sort.

📏 2. Sliding Window & Prefix Sums
- Best Time to Buy and Sell Stock (Easy)

Given daily prices, find the max profit from one buy and one sell.
Why: Teaches sliding window technique and greedy algorithms.

- Longest Substring Without Repeating Characters (Medium)

Find the length of the longest substring without repeating characters.
Why: Classic sliding window + hash set challenge.

- Maximum Subarray (Easy)

Find the contiguous subarray with the largest sum.
Why: Introduces Kadane’s Algorithm; foundation for dynamic programming.

🧵 3. Strings
- Valid Anagram (Easy)

Determine if two strings are anagrams.
Why: Focuses on character counting and hash maps.

- Group Anagrams (Medium)

Group strings that are anagrams of each other.
Why: Requires mapping sorted strings or frequency signatures.

- Longest Palindromic Substring (Medium)

Find the longest substring that is a palindrome.
Why: Introduces string-based dynamic programming or expand-around-center.

🌲 4. Binary Trees
- Invert Binary Tree (Easy)

Mirror a binary tree.
Why: Tests basic recursion and tree traversal.

- Maximum Depth of Binary Tree (Easy)

Find the height of the tree.
Why: Recursion or BFS – a tree traversal fundamental.

- Validate Binary Search Tree (Medium)

Check if a binary tree is a valid BST.
Why: Combines tree traversal with value constraints.

- Lowest Common Ancestor of a BST (Medium)

Find the lowest node that’s an ancestor of two given nodes.
Why: Uses recursion or BST properties for optimization.

🧮 5. Binary Search & Sorting
- Binary Search (Easy)

Implement binary search on a sorted array.
Why: Interviewers love it; it’s a core CS concept.

- Search in Rotated Sorted Array (Medium)

Perform binary search on an array rotated at some pivot.
Why: Advanced binary search logic with edge case handling.

- Kth Smallest Element in a BST (Medium)

Find the Kth smallest element in a BST.
Why: Combines in-order traversal with counting logic.

🧶 6. Linked Lists
- Reverse Linked List (Easy)

Reverse a singly linked list.
Why: Tests pointer manipulation, recursion vs iteration.

- Merge Two Sorted Lists (Easy)

Merge two sorted linked lists into one sorted list.
Why: Classic pointer-based merge logic.

- Linked List Cycle (Easy)

Detect if a cycle exists in a linked list.
Why: Tests Floyd’s Tortoise & Hare (fast/slow pointer) approach.

- Add Two Numbers (Medium)

Add two numbers represented by linked lists (in reverse).
Why: Combines list traversal, digit carry, and node manipulation.

📦 7. Stacks, Queues & Heaps
- Valid Parentheses (Easy)

Check if a string of brackets is valid (well-formed).
Why: Stack fundamentals and matching pairs.

- Min Stack (Medium)

Design a stack that supports getting the min in O(1) time.
Why: Combines data structure design with stack behavior.

- Implement Queue using Stacks (Easy)

Build a queue using two stacks.
Why: Tests understanding of how stacks can simulate other structures.

- Merge K Sorted Lists (Hard) – Optional but valuable

Merge K sorted linked lists into one sorted list.
Why: Real-world pattern; uses priority queue (heap) and list merging.
